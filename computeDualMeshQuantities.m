function grid = computeDualMeshQuantities(grid)
% Function to compute:
% - the volume of the dual cells
% - the lengths of edges between the dual cells generated by x_i and x_j

M = sparse(grid.N, grid.N);
vol = zeros(grid.N, 1);

ix = [];
iy = [];
lij = [];
nuijx = [];
nuijy = [];

sE = size(grid.E);

for i=1:grid.N
	cell_i = grid.C{i};

    % Firstly, we compute the volume of the dual cells
	vol(i) = polyarea(grid.V(cell_i,1), grid.V(cell_i,2));

    % Now, we look for the neighborhood information
    [a,b] = find(grid.E==i);
    neighbors = grid.E(sub2ind(sE,3-a,b));
    for j = neighbors'
        cell_j = grid.C{j};
		[pnts,tmpi,tmpj] = intersect(cell_i, cell_j,'stable');
        lp = length(pnts);
        dtmpi = diff(tmpi);
        tmp2 = find(dtmpi>1);
        if ~isempty(tmp2)
            pnts = [pnts(tmp2+1:end),pnts(1:tmp2)];
        end
            
        if lp > 1
            ix = [ix, i];
            iy = [iy, j];
            % if lp > 2
            %     keyboard
            % end
            this_lij = sqrt(sum(diff(grid.V(pnts,:)).^2,2));
            this_nij = fliplr(diff(grid.V(pnts,:)))./(this_lij);
            this_nij(:,1) = (this_nij(:,1).*(-1));
            this_nuij = sum(this_nij.* this_lij,1);

            % Factor 0.5 ensures correct final scaling since each edge is counted twice
            % Half of the total length of edge between cell i and j
            lij = [lij, 0.5*sum(this_lij)];
            nuijx = [nuijx, 0.5*this_nuij(1)];
            nuijy = [nuijy, 0.5*this_nuij(2)];
        end
    end
    % for j=(i+1):grid.N
    %     cell_j = grid.C{j};
    %     % fprintf('i %d j %d\n',i,j)
    % 	pnts = intersect(cell_i, cell_j);
    %     % Cells are neighbors, iff they share exactly two points
    % 	if length(pnts) == 2 && all(pnts ~= 1)
    %         ix = [ix, i];
    %         iy = [iy, j];
    % 
    %         % Length of edge between Voronoi cells
    %         lij = [lij, sqrt(sum(diff(grid.V(pnts,:)).^2))];
    % 	end
    % end
end
% grid.edges = [ix;iy];
grid.muOmega = vol;
grid.muGamma = sparse([ix,iy], [iy,ix], [lij,lij], grid.N, grid.N);
grid.Ni = sparse([ix,iy], [iy,ix], ones(size([lij,lij])), grid.N, grid.N);

% WARNING This is only correct for dual voronoi meshes
nij = grid.p(:,[iy,ix]) - grid.p(:,[ix, iy]);
muij = sqrt(sum(nij.^2,1));
grid.Nuij{1} = sparse([ix,iy], [iy,ix], [-nuijx, nuijx], grid.N, grid.N);
grid.Nuij{2} = sparse([ix,iy], [iy,ix], [-nuijy, nuijy], grid.N, grid.N);

grid.Nij{1} = 0.5*sparse([ix,iy], [iy,ix], nij(1,:)./muij, grid.N, grid.N);
grid.Nij{2} = 0.5*sparse([ix,iy], [iy,ix], nij(2,:)./muij, grid.N, grid.N);

% unique(sqrt(grid.Nij{1}.^2 + grid.Nij{2}.^2))

end
